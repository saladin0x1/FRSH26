# Mini Projet :  Flex et Bison

## Introduction

Ce projet présente et teste un compilateur simple utilisant **Flex** (outil de génération de scanner) et **Bison** (outil de génération de parseur). Le compilateur développé dans ce projet effectue un chiffrement de texte simple basé sur un décalage aléatoire des lettres, utilisant une méthode de chiffrement similaire au **ROT13**, appelée **FRSH26**. Cette méthode consiste à décaler chaque lettre du texte d'un nombre aléatoire de positions dans l'alphabet. Pour plus d'informations, vous pouvez consulter la référence à [ROT13 sur Wikipedia](https://en.wikipedia.org/wiki/ROT13).


## Objectif

L'objectif est de créer un scanner avec **Flex** et un parseur avec **Bison**, capables de :

- Analyser un texte et extraire les lettres, espaces et caractères autres.
- Appliquer un chiffrement simple sur les lettres avec un décalage aléatoire.
- Afficher le texte chiffré.

## Structure du projet

Le projet se compose de trois fichiers principaux : un fichier **scanner** (`scanner.l`), un fichier **parser** (`parser.y`), et un fichier **Makefile** pour la compilation automatique.

### Le fichier `parser.y` (Bison)

Ce fichier définit les règles de syntaxe et les actions à effectuer lors de l'analyse du texte. Voici un extrait du code source de ce fichier :

```c
%{
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <time.h>

void frsh26(char *ch, int shift);
int generate_shift(int base_shift, int index);

extern char *yytext;
extern int yylex();
extern int yyerror(char *s);
%}

%token LETTER
%token WHITESPACE
%token OTHER
%token ERROR

%%

program:
    /* Vide */
  | program statement
;

statement:
    LETTER            { 
        int shift = generate_shift(5, yylen);
        frsh26(&yytext[0], shift); 
        printf("%c", yytext[0]);
    }
  | WHITESPACE        { printf(" "); }
  | OTHER             { printf("%c", yytext[0]); }
  | ERROR             { yyerror("Caractère invalide rencontré"); }
;

%%

int generate_shift(int base_shift, int index) {
    srand(time(NULL) + index);
    return (base_shift + rand() % 26);
}

void frsh26(char *ch, int shift) {
    if (isupper(*ch)) {
        *ch = (*ch - 'A' + shift) % 26 + 'A';
    } else if (islower(*ch)) {
        *ch = (*ch - 'a' + shift) % 26 + 'a';
    }
}

int main() {
    printf("Entrez le texte à chiffrer avec FRSH26 :\n");
    yyparse();
    return 0;
}

int yyerror(char *s) {
    fprintf(stderr, "Erreur : %s\n", s);
    return 0;
}
```

### Le fichier `scanner.l` (Flex)

Le fichier **scanner** contient les expressions régulières qui permettent de détecter les différents types de tokens (lettres, espaces, caractères autres). Voici un extrait de ce fichier :

```c
%{
#include "parser.tab.h"

%option noyywrap
%option nounput
%option noyyunput
%}

%%
[[:alpha:]]      { return LETTER; }
[[:space:]]      { return WHITESPACE; }
.                 { return ERROR; }
%%

int yywrap(void) {
    return 1;
}
```

### Le fichier `Makefile`

Le fichier `Makefile` permet de compiler le projet de manière simple et rapide. Voici un exemple de Makefile adapté à ce projet :

```Makefile
# Makefile for FRSH26 encryption program

# Compiler and flags
CC = gcc
CFLAGS = -Wall -Wno-unused-function -Wno-unneeded-internal-declaration  # Add flags to suppress warnings
LDFLAGS = -L/usr/local/opt/flex/lib -lfl   # Link with the Flex library

# Source files and target executable
LEX_SRC = lex.yy.c  # The C source file generated by Flex
BISON_SRC = parser.tab.c  # The C source file generated by Bison
EXEC = frsh26_encryption  # The name of the executable to be generated

# Default target: Build the executable
all: $(EXEC)

# Rule to create the final executable
$(EXEC): $(LEX_SRC) $(BISON_SRC)
	# Compile lex.yy.c and parser.tab.c into the final executable
	$(CC) $(CFLAGS) $(LEX_SRC) $(BISON_SRC) -o $(EXEC) $(LDFLAGS)

# Rule to generate lex.yy.c from scanner.l using Flex
lex.yy.c: scanner.l
	# Run Flex to generate lex.yy.c from scanner.l
	@echo "Running Flex on scanner.l..."
	flex scanner.l

# Rule to generate parser.tab.c and parser.tab.h from parser.y using Bison
parser.tab.c parser.tab.h: parser.y
	# Run Bison to generate parser.tab.c and parser.tab.h from parser.y
	@echo "Running Bison on parser.y..."
	bison -d parser.y

# Clean rule: Remove generated files and the executable
clean:
	# Remove generated files and executable
	rm -f $(EXEC) $(LEX_SRC) $(BISON_SRC) parser.tab.h
	@echo "Cleaned up generated files."


```

## Compilation et Exécution

1. **Génération du scanner et du parseur :**
   Pour générer les fichiers nécessaires à la compilation, exécutez simplement la commande suivante :

   ```bash
   make
   ```

2. **Exécution du compilateur :**
   Lancez le compilateur avec la commande :

   ```bash
   ./frsh26_encryption
   ```

   Entrez un texte, et le compilateur vous renverra le texte chiffré avec la méthode FRSH26.

## Conclusion

Ce projet m'a permis de comprendre les bases de l'utilisation de **Flex** et **Bison** pour créer un compilateur simple et d'aborder de manière pratique plutôt que théorique. Je peux étendre ce projet en ajoutant d'autres fonctionnalités, comme le support de plus de types de tokens ou des règles de syntaxe plus complexes.
